# 缠论算法实现需求文档

## 目录

1. [项目概述](#项目概述)

2. [基础数据结构](#基础数据结构)

3. [分型识别算法](#分型识别算法)

4. [笔的划分算法](#笔的划分算法)

5. [线段识别算法](#线段识别算法)

6. [中枢识别算法](#中枢识别算法)

7. [中枢扩张识别算法](#中枢扩张识别算法)

8. [背驰判断算法](#背驰判断算法)

9. [买卖点识别算法](#买卖点识别算法)

10. [技术栈要求](#技术栈要求)

11. [实现优先级](#实现优先级)

---

## 项目概述

### 目标

实现缠论的核心算法，包括分型识别、笔划分、线段识别、中枢识别、背驰判断和买卖点识别等功能。

### 输入数据

- OHLCV 格式的 K 线数据

- 时间戳、开盘价、最高价、最低价、收盘价、成交量

### 输出结果

- 分型识别结果（顶分型、底分型）

- 笔划分结果（向上笔、向下笔）

- 线段识别结果（向上线段、向下线段）

- 中枢识别结果（中枢区间、类型、级别）

- 背驰判断结果（背驰类型、强度）

- 买卖点识别结果（买卖点类型、价格、时间）

---

## 基础数据结构

### 1. K 线数据结构

```
class Candlestick:

   def __init__(self, timestamp, open_price, high, low, close, volume):

       self.timestamp = timestamp  # 时间戳

       self.open = open_price      # 开盘价

       self.high = high            # 最高价

       self.low = low              # 最低价

       self.close = close          # 收盘价

       self.volume = volume        # 成交量



       # 分析结果标记

       self.top_fractal = False    # 是否顶分型

       self.bottom_fractal = False # 是否底分型

       self.pen_type = 0           # 笔类型：0-无，1-向上笔，-1-向下笔

       self.segment_type = 0       # 线段类型：0-无，1-向上线段，-1-向下线段
```

### 2. 分型数据结构

```
class Fractal:

   def __init__(self, type_, index, price, left_index, right_index):

       self.type = type_           # 类型：'top'或'bottom'

       self.index = index          # 当前K线索引

       self.price = price          # 分型价格

       self.left_index = left_index# 左侧K线索引

       self.right_index = right_index# 右侧K线索引
```

### 3. 笔数据结构

```
class Pen:

   def __init__(self, type_, start_index, end_index, start_price, end_price):

       self.type = type_           # 类型：'up'或'down'

       self.start_index = start_index # 起始K线索引

       self.end_index = end_index  # 结束K线索引

       self.start_price = start_price # 起始价格

       self.end_price = end_price  # 结束价格

       self.length = abs(end_price - start_price) # 笔长度
```

### 4. 线段数据结构

```
class Segment:

   def __init__(self, type_, start_index, end_index, start_price, end_price, pens):

       self.type = type_           # 类型：'up'或'down'

       self.start_index = start_index # 起始K线索引

       self.end_index = end_index  # 结束K线索引

       self.start_price = start_price # 起始价格

       self.end_price = end_price  # 结束价格

       self.pens = pens            # 包含的笔列表

       self.length = abs(end_price - start_price) # 线段长度
```

### 5. 中枢数据结构

```
class Center:

   def __init__(self, start_index, end_index, high, low, segments, type_):

       self.start_index = start_index # 起始K线索引

       self.end_index = end_index    # 结束K线索引

       self.high = high              # 中枢上沿

       self.low = low                # 中枢下沿

       self.mid = (high + low) / 2   # 中枢中点

       self.height = high - low      # 中枢高度

       self.segments = segments      # 构成中枢的线段列表

       self.type = type_             # 类型：'up'或'down'

       self.level = 0                # 中枢级别
```

### 6. 背驰数据结构

```
class Divergence:

   def __init__(self, type_, start_segment, end_segment, strength):

       self.type = type_             # 类型：'top'或'bottom'

       self.start_segment = start_segment # 起始线段

       self.end_segment = end_segment   # 结束线段

       self.strength = strength      # 背驰强度：0-1之间

       self.confidence = 0.0         # 置信度：0-1之间
```

### 7. 买卖点数据结构

```
class TradingSignal:

   def __init__(self, type_, level, price, timestamp, reason):

       self.type = type_             # 类型：'buy'或'sell'

       self.level = level            # 级别：1, 2, 3

       self.price = price            # 价格

       self.timestamp = timestamp    # 时间戳

       self.reason = reason          # 产生原因

       self.confidence = 0.0         # 置信度：0-1之间
```

---

## 分型识别算法

### 1. K 线包含关系处理

#### 包含关系定义

当一根 K 线的高低点完全包含在另一根 K 线的高低点范围内时，称为包含关系。

#### 处理规则

- **向上走势**：取两根 K 线的高点中的较高值和低点中的较高值

- **向下走势**：取两根 K 线的高点中的较低值和低点中的较低值

#### 算法步骤

```
输入：原始K线列表

输出：处理后的K线列表

步骤：

1. 初始化结果列表

2. 遍历原始K线列表

3. 对于每根K线，检查与前一根K线是否存在包含关系

4. 如果存在包含关系，按照规则合并K线

5. 如果不存在包含关系，直接添加到结果列表

6. 返回处理后的K线列表
```

### 2. 顶分型识别

#### 定义

由 3 根相邻 K 线组成，第二根 K 线的高点为 3 根 K 线中的最高点，且其低点高于第一根与第三根 K 线的低点。

#### 判定条件

```
条件1：K线2的高点 > K线1的高点

条件2：K线2的高点 > K线3的高点

条件3：K线2的低点 > K线1的低点

条件4：K线2的低点 > K线3的低点
```

#### 算法步骤

```
输入：处理后的K线列表

输出：顶分型列表

步骤：

1. 初始化顶分型列表

2. 从第2根K线开始遍历（索引1到n-2）

3. 对于每根K线i，检查是否满足顶分型条件

4. 如果满足条件，创建顶分型对象并添加到列表

5. 返回顶分型列表
```

### 3. 底分型识别

#### 定义

由 3 根相邻 K 线组成，第二根 K 线的低点为 3 根 K 线中的最低点，且其高点低于第一根与第三根 K 线的高点。

#### 判定条件

```
条件1：K线2的低点 < K线1的低点

条件2：K线2的低点 < K线3的低点

条件3：K线2的高点 < K线1的高点

条件4：K线2的高点 < K线3的高点
```

#### 算法步骤

```
输入：处理后的K线列表

输出：底分型列表

步骤：

1. 初始化底分型列表

2. 从第2根K线开始遍历（索引1到n-2）

3. 对于每根K线i，检查是否满足底分型条件

4. 如果满足条件，创建底分型对象并添加到列表

5. 返回底分型列表
```

---

## 笔的划分算法

### 1. 向上笔识别

#### 定义

连接相邻的底分型和顶分型，顶分型的高点高于底分型的高点。

#### 判定条件

```
条件1：起始点为底分型

条件2：结束点为顶分型

条件3：顶分型的高点 > 底分型的高点

条件4：顶底分型之间至少有1根独立K线

条件5：整体呈现上升趋势
```

### 2. 向下笔识别

#### 定义

连接相邻的顶分型和底分型，底分型的低点低于顶分型的低点。

#### 判定条件

```
条件1：起始点为顶分型

条件2：结束点为底分型

条件3：底分型的低点 < 顶分型的低点

条件4：顶底分型之间至少有1根独立K线

条件5：整体呈现下降趋势
```

### 3. 笔划分算法

#### 新笔规则（推荐）

```
条件1：顶底分型之间至少有3根非包含K线

条件2：整个笔至少包含5根K线

条件3：必须满足方向要求（向上笔顶高于底，向下笔底低于顶）
```

#### 算法步骤

```
输入：分型列表、原始K线数据

输出：笔列表

步骤：

1. 初始化笔列表

2. 按时间顺序排序分型列表

3. 遍历分型列表，寻找相邻的不同类型分型

4. 对于每对相邻的底分型和顶分型，检查是否满足向上笔条件

5. 对于每对相邻的顶分型和底分型，检查是否满足向下笔条件

6. 如果满足条件，创建笔对象并添加到列表

7. 返回笔列表
```

---

## 线段识别算法

### 1. 向上线段识别

#### 定义

由至少 3 笔组成，序列为：向上笔 + 向下笔 + 向上笔，且内部任何向下笔的高低点不能完全覆盖前一个向上笔。

#### 判定条件

```
条件1：至少包含3笔

条件2：笔的方向必须交替出现（上-下-上）

条件3：第二笔的高点 < 第一笔的高点

条件4：第二笔的低点 > 第三笔的低点

条件5：整体呈现上升趋势
```

### 2. 向下线段识别

#### 定义

由至少 3 笔组成，序列为：向下笔 + 向上笔 + 向下笔，且内部任何向上笔的高低点不能完全覆盖前一个向下笔。

#### 判定条件

```
条件1：至少包含3笔

条件2：笔的方向必须交替出现（下-上-下）

条件3：第二笔的低点 < 第一笔的低点

条件4：第二笔的高点 > 第三笔的高点

条件5：整体呈现下降趋势
```

### 3. 线段破坏识别

#### 向上线段破坏条件

需要出现以下三个笔：

```
条件1：第一笔为有效的向下笔（P1）

条件2：第二笔为有效的向上笔（P2）

条件3：第三笔为有效的向下笔（P3）

条件4：P1的高点 > P2的高点 > P3的高点

条件5：P1的低点 < P2的低点 < P3的低点
```

#### 向下线段破坏条件

需要出现以下三个笔：

```
条件1：第一笔为有效的向上笔（P1）

条件2：第二笔为有效的向下笔（P2）

条件3：第三笔为有效的向上笔（P3）

条件4：P1的低点 < P2的低点 < P3的低点

条件5：P1的高点 > P2的高点 > P3的高点
```

#### 线段识别算法步骤

```
输入：笔列表

输出：线段列表

步骤：

1. 初始化线段列表

2. 遍历笔列表，寻找满足线段构成条件的笔序列

3. 对于每组满足条件的3笔，检查是否构成向上或向下线段

4. 如果构成线段，创建线段对象并添加到列表

5. 继续寻找后续的线段

6. 检查线段是否被破坏，并更新线段状态

7. 返回线段列表
```

---

## 中枢识别算法

### 1. 中枢定义

由至少三个连续次级别走势类型重叠部分构成的价格区间。

### 2. 中枢计算方法

```
中枢上沿 = 三个走势类型高点中的最小值

中枢下沿 = 三个走势类型低点中的最大值

中枢高度 = 中枢上沿 - 中枢下沿

中枢中点 = (中枢上沿 + 中枢下沿) / 2
```

### 3. 上涨中枢识别

#### 构成序列

下 - 上 - 下

#### 判定条件

```
条件1：由三个连续的线段组成

条件2：线段方向依次为向下、向上、向下

条件3：第二个线段的高点 < 第一个线段的高点

条件4：第二个线段的低点 > 第三个线段的低点

条件5：三个线段存在重叠区域
```

### 4. 下跌中枢识别

#### 构成序列

上 - 下 - 上

#### 判定条件

```
条件1：由三个连续的线段组成

条件2：线段方向依次为向上、向下、向上

条件3：第二个线段的低点 < 第一个线段的低点

条件4：第二个线段的高点 > 第三个线段的高点

条件5：三个线段存在重叠区域
```

### 5. 中枢识别算法步骤

```
输入：线段列表

输出：中枢列表

步骤：

1. 初始化中枢列表

2. 遍历线段列表，寻找连续的三个线段

3. 对于每组三个连续线段，计算重叠区域

4. 如果存在重叠区域，计算中枢的上沿和下沿

5. 判断中枢类型（上涨或下跌）

6. 创建中枢对象并添加到列表

7. 继续寻找后续的中枢

8. 返回中枢列表
```

---

## 中枢扩张识别算法

### 1. 时间扩张识别

#### 判定条件

```
条件1：中枢的震荡时间超过了该级别正常中枢的2-3倍

条件2：中枢内部的次级别走势数量超过了5段

条件3：震荡节奏变得缓慢，时间间隔拉长
```

### 2. 空间扩张识别

#### 判定条件

```
条件1：震荡幅度超过了原中枢高度的1.5-2倍

条件2：价格突破了原中枢的上边界或下边界

条件3：新的震荡范围包含了原中枢范围
```

### 3. 结构扩张识别

#### 判定条件

```
条件1：中枢内部的次级别走势超过了5段

条件2：形成了高级别的中枢结构

条件3：走势结构变得更加复杂
```

### 4. 中枢扩张识别算法步骤

```
输入：中枢列表、线段列表

输出：扩张中枢列表

步骤：

1. 初始化扩张中枢列表

2. 对于每个已识别的中枢，分析其后续走势

3. 检查是否满足时间扩张条件

4. 检查是否满足空间扩张条件

5. 检查是否满足结构扩张条件

6. 如果满足任意一种扩张条件，标记为扩张中枢

7. 记录扩张的类型和程度

8. 返回扩张中枢列表
```

---

## 背驰判断算法

### 1. MACD 指标计算

```
MACD = EMA(12) - EMA(26)

Signal = EMA(MACD, 9)

Histogram = MACD - Signal
```

### 2. 顶背驰判断

#### 判定条件

```
条件1：价格创出新高

条件2：MACD值未创出新高

条件3：MACD红柱面积减小

条件4：MACD黄白线高度降低

条件5：通常伴随成交量萎缩
```

### 3. 底背驰判断

#### 判定条件

```
条件1：价格创出新低

条件2：MACD值未创出新低

条件3：MACD绿柱面积减小

条件4：MACD黄白线高度升高

条件5：通常伴随成交量萎缩后放大
```

### 4. 盘整背驰判断

#### 判定条件

```
条件1：存在一个已完成的中枢

条件2：比较进入中枢的线段a和离开中枢的线段c

条件3：线段c的MACD面积 < 线段a的MACD面积

条件4：黄白线有拉回0轴附近的动作
```

### 5. 趋势背驰判断

#### 判定条件

```
条件1：存在至少两个同方向的中枢

条件2：最后一个中枢的离开段与进入段发生背驰

条件3：MACD指标出现明显的背离

条件4：通常出现在趋势走势的末端
```

### 6. 背驰判断算法步骤

```
输入：价格数据、中枢列表、线段列表

输出：背驰列表

步骤：

1. 计算MACD指标

2. 遍历中枢列表，分析每个中枢的进入段和离开段

3. 对于每个中枢，比较进入段和离开段的MACD

4. 检查是否满足顶背驰或底背驰条件

5. 检查是否满足盘整背驰条件

6. 检查是否满足趋势背驰条件

7. 如果满足背驰条件，计算背驰强度和置信度

8. 创建背驰对象并添加到列表

9. 返回背驰列表
```

---

## 买卖点识别算法

### 1. 第一类买卖点识别

#### 第一类买点条件

```
条件1：存在至少两个下跌中枢

条件2：最后一个中枢的离开段与进入段发生底背驰

条件3：MACD出现底背驰信号

条件4：通常出现在趋势的末端
```

#### 第一类卖点条件

```
条件1：存在至少两个上涨中枢

条件2：最后一个中枢的离开段与进入段发生顶背驰

条件3：MACD出现顶背驰信号

条件4：通常出现在趋势的末端
```

### 2. 第二类买卖点识别

#### 第二类买点条件

```
条件1：第一类买点已经确认

条件2：次级别出现回调

条件3：回调低点 > 第一类买点低点

条件4：回调后出现底分型确认

条件5：MACD在0轴下方金叉
```

#### 第二类卖点条件

```
条件1：第一类卖点已经确认

条件2：次级别出现反弹

条件3：反弹高点 < 第一类卖点高点

条件4：反弹后出现顶分型确认

条件5：MACD在0轴上方死叉
```

### 3. 第三类买卖点识别

#### 第三类买点条件

```
条件1：存在至少一个已完成的中枢

条件2：价格向上突破中枢上沿

条件3：突破时有成交量配合

条件4：突破后出现回踩

条件5：回踩低点 > 中枢上沿
```

#### 第三类卖点条件

```
条件1：存在至少一个已完成的中枢

条件2：价格向下突破中枢下沿

条件3：突破时有成交量配合

条件4：突破后出现回抽

条件5：回抽高点 < 中枢下沿
```

### 4. 买卖点识别算法步骤

```
输入：背驰列表、中枢列表、价格数据

输出：买卖点列表

步骤：

1. 初始化买卖点列表

2. 遍历背驰列表，寻找满足第一类买卖点条件的背驰

3. 对于每个第一类买卖点，寻找后续的第二类买卖点

4. 遍历中枢列表，寻找满足第三类买卖点条件的突破

5. 对于每个识别到的买卖点，计算置信度

6. 创建买卖点对象并添加到列表

7. 按时间顺序排序买卖点列表

8. 返回买卖点列表
```

---

## 技术栈要求

要求Web端可视化实现，使用Python技术栈

实现步骤：

1、基础可视化，画出K线图和MACD指标

2、逐步实现缠论中的各个概念，包括笔、线段、中枢等，并且每实现一个都要在可视化界面上展示出来